#_________This is for demonstration purpose only___________#

#________The official WGCNA website recommends at least 15 samples for analysis____________#



#install.packages("WGCNA") 
#BiocManager::install("impute")
library(WGCNA)
library(tidyverse)
library(DESeq2)
#install.packages("magrittr")
library(magrittr)
#BiocManager::install("GEOquery")
library(GEOquery)
#BiocManager::install("ComplexHeatmap")
library(ComplexHeatmap)
#install.packages("corrplot")
library(corrplot)
#install.packages("pheatmap")
library(pheatmap)
#BiocManager::install("gridExtra")
library(gridExtra)


setwd("D:/WGCNA")


# 1. Fetch Data

data <- read.delim('GSE223846_gene_count.txt', header = T)

# get metadata
geo_id <- "GSE223846"
gse <- getGEO(geo_id, GSEMatrix = TRUE)
phenoData <- pData(phenoData(gse[[1]]))
head(phenoData)
phenoData <- phenoData[,c(1,2,19,45)]

names(phenoData)

# prepare data

data[1:5,1:10]        # Look at first 5 rows and 10 columns

data2 <- data %>% 
  gather(key = 'samples', value = 'counts', -gene_id) %>%
  inner_join(., phenoData, by = c('samples' = 'description')) %>% 
  select(1,3,5) %>% 
  spread(key = 'geo_accession', value = 'counts') %>% 
  column_to_rownames(var = 'gene_id')

data2[1:5,1:9]        # Look at first 5 rows and 9 columns

#OR

library(tidyverse)

data2 <- data %>% 
  gather(key = 'samples', value = 'counts', -gene_id) %>%
  inner_join(phenoData, by = c('samples' = 'description')) %>% 
  select(1,3,4) %>%  # Ensure these column indices exist
  spread(key = 'title', value = 'counts') %>% 
  column_to_rownames(var = 'gene_id')

data2[1:5,1:9]        # Look at first 5 rows and 9 columns



# 2. QC - outlier detection ------------------------------------------------
# detect outlier genes

gsg <- goodSamplesGenes(t(data2))
summary(gsg)

gsg$allOK

table(gsg$goodGenes)

table(gsg$goodSamples)


# remove genes that are detectd as outliers
data3 <- data2[gsg$goodGenes == TRUE,]

# detect outlier samples - hierarchical clustering - method 1

htree <- hclust(dist(t(data3)), method = "average")
plot(htree)


# pca - method 2
pca <- prcomp(t(data3))
pca.dat <- pca$x

pca.var <- pca$sdev^2
pca.var.percent <- round(pca.var/sum(pca.var)*100, digits = 2)

pca.dat <- as.data.frame(pca.dat)

ggplot(pca.dat, aes(PC1, PC2)) +
  geom_point() +
  geom_text(label = rownames(pca.dat)) +
  labs(x = paste0('PC1: ', pca.var.percent[1], ' %'),
       y = paste0('PC2: ', pca.var.percent[2], ' %'))



# exclude outlier samples (Lysine samples removed after outliar removal)
samples.to.be.excluded <- c('Differentiated 3T3-L1 cells, lysine free 1', 'Differentiated 3T3-L1 cells, lysine free 2', 'Differentiated 3T3-L1 cells, lysine free 3')
data4 <- data3[,!(colnames(data3) %in% samples.to.be.excluded)]

htree <- hclust(dist(t(data4)), method = "average")
plot(htree)

# pca - method 2
pca <- prcomp(t(data4))
pca.dat <- pca$x

pca.var <- pca$sdev^2
pca.var.percent <- round(pca.var/sum(pca.var)*100, digits = 2)

pca.dat <- as.data.frame(pca.dat)

ggplot(pca.dat, aes(PC1, PC2)) +
  geom_point() +
  geom_text(label = rownames(pca.dat)) +
  labs(x = paste0('PC1: ', pca.var.percent[1], ' %'),
       y = paste0('PC2: ', pca.var.percent[2], ' %'))


# 3. Normalization ----------------------------------------------------------------------
# create a deseq2 dataset


#install.packages("tibble")  
library(tibble)
library(dplyr)

colData <- phenoData %>%
  rownames_to_column(var = "temp_rowname") %>%  # Store current row names safely
  mutate(title_col = title) %>%                 # Duplicate 'title' column
  column_to_rownames(var = "title") %>%         # Set 'title' as row names
  select(-temp_rowname)                         # Remove temporary row name column

# exclude outlier samples from phenodata

samples.to.be.excluded <- c('Differentiated 3T3-L1 cells, lysine free 1', 'Differentiated 3T3-L1 cells, lysine free 2', 'Differentiated 3T3-L1 cells, lysine free 3')

colData <- colData %>% 
  filter(!row.names(.) %in% samples.to.be.excluded)
names(colData)


# fixing column names in colData
names(colData) <- gsub(':ch1', '', names(colData))
names(colData) <- gsub('_col', '', names(colData))

# making the rownames and column names identical
all(rownames(colData) %in% colnames(data4))

data4 <- data4[, rownames(colData)]
all(rownames(colData) == colnames(data4))

#Plot before normalization
library(dplyr)
library(tidyr)

mdata <- data4 %>%           # Convert wide to long format
  pivot_longer(cols = everything(), names_to = "name", values_to = "value") %>%
  mutate(group = ifelse(grepl("Undifferentiated", name), "Undifferentiated", "Differentiated"))  # Define groups

p <- mdata %>%
  ggplot(aes(x = name, y = value)) +
  geom_violin() +
  geom_point(alpha = 0.2) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = "Treatment Groups", y = "gene Counts") +
  facet_grid(cols = vars(group), drop = TRUE, scales = "free_x")  

print(p)  # Display the plot

# create dds
dds <- DESeqDataSetFromMatrix(countData = data4,
                              colData = colData,
                              design = ~ 1) # not spcifying model



## remove all genes with counts < 15 in more than 75% of samples (6*0.75=4.5)
## suggested by WGCNA on RNAseq FAQ

dds75 <- dds[rowSums(counts(dds) >= 15) >= 5,]
nrow(dds75) #12193 genes

# perform variance stabilization
dds_norm <- vst(dds75)


# get normalized counts

assay(dds_norm) %>% 
head()

norm.counts <- assay(dds_norm) %>% 
  t()

library(tidyverse)

#Plot after normalization

mdata_norm <- norm.counts %>%      # Convert normalized counts to long format
  as.data.frame() %>%
  rownames_to_column(var = "sample") %>%
  pivot_longer(cols = -sample, names_to = "gene", values_to = "value") %>%
  left_join(colData %>% rownames_to_column(var = "sample"), by = "sample")  # Add treatment info


str(mdata_norm)
head(mdata_norm)

p_norm <- ggplot(mdata_norm, aes(x = title, y = value)) +  # Use title for better readability
  geom_violin() +
  geom_point(alpha = 0.2) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(x = "Treatment Groups", y = "Normalized gene Counts") +
  facet_grid(cols = vars(treatment), drop = TRUE, scales = "free_x")  # Use "treatment"

print(p_norm)



# 4. Network Construction  ---------------------------------------------------
# Choose a set of soft-thresholding powers
power <- c(c(1:10), seq(from = 12, to = 50, by = 2))

power

# Call the network topology analysis function
sft <- pickSoftThreshold(norm.counts,
                         powerVector = power,
                         networkType = "signed", #signed is preffeered
                         verbose = 5)
        #or
sft <- pickSoftThreshold(norm.counts, powerVector = power, networkType = "unsigned")

       #or
sft <- pickSoftThreshold(norm.counts, powerVector = power, networkType = "signed hybrid")



sft.data <- sft$fitIndices

# visualization to pick power

a1 <- ggplot(sft.data, aes(Power, SFT.R.sq, label = Power)) +
  geom_point() +
  geom_text(nudge_y = 0.1) +
  geom_hline(yintercept = 0.8, color = 'red') +
  labs(x = 'Power', y = 'Scale free topology model fit, signed R^2') +
  theme_classic()


a2 <- ggplot(sft.data, aes(Power, mean.k., label = Power)) +
  geom_point() +
  geom_text(nudge_y = 0.1) +
  labs(x = 'Power', y = 'Mean Connectivity') +
  theme_classic()



grid.arrange(a1, a2, nrow = 2)


# convert matrix to numeric
norm.counts[] <- sapply(norm.counts, as.numeric)

soft_power <- 30  #select from the graph (0.8 threshold)
temp_cor <- cor
cor <- WGCNA::cor


# memory estimate w.r.t blocksize
bwnet <- blockwiseModules(norm.counts,
                          maxBlockSize = 8000,
                          TOMType = "signed",  #based on power
                          power = soft_power,
                          mergeCutHeight = 0.25,
                          numericLabels = FALSE,
                          randomSeed = 1234,
                          verbose = 3)


cor <- temp_cor
# 5. Module Eigengenes ---------------------------------------------------------
module_eigengenes <- bwnet$MEs


# Print out a preview
head(module_eigengenes)


# get number of genes for each module
table(bwnet$colors)




# Plot the dendrogram and the module colors before and after merging underneath
plotDendroAndColors(bwnet$dendrograms[[1]], cbind(bwnet$unmergedColors, bwnet$colors),
                    c("unmerged", "merged"),
                    dendroLabels = FALSE,
                    addGuide = TRUE,
                    hang= 0.03,
                    guideHang = 0.05)
#OR#

length(bwnet$dendrograms[[1]]$order)  # Number of genes in dendrogram
length(bwnet$unmergedColors)          # Number of unmerged module colors
length(bwnet$colors)                  # Number of merged module colors

# Extract the order of genes from the dendrogram
orderedGenes <- bwnet$dendrograms[[1]]$order  

# Subset unmerged and merged colors based on the genes in the dendrogram
filteredUnmergedColors <- bwnet$unmergedColors[orderedGenes]
filteredMergedColors <- bwnet$colors[orderedGenes]

# Re-run the plot with corrected colors
plotDendroAndColors(bwnet$dendrograms[[1]], 
                    cbind(filteredUnmergedColors, filteredMergedColors),
                    c("unmerged", "merged"),
                    dendroLabels = FALSE,
                    addGuide = TRUE,
                    hang = 0.03,
                    guideHang = 0.05)


# grey module = all genes that doesn't fall into other modules were assigned to the grey module





# 6A. Relate modules to traits --------------------------------------------------
# module trait associations


# create traits file - binarize categorical variables
traits <- colData %>% 
  mutate(treatment_bin = ifelse(grepl('Adipogenic differentiation', treatment), 1, 0)) %>% 
  select(5)


# binarize categorical variables

###Binarize a second varriable and merge

colData$severity <- factor(colData$severity, levels = c("Healthy", "Convalescent", "ICU", "Moderate", "Severe"))

severity.out <- binarizeCategoricalColumns(colData$severity,
                                           includePairwise = FALSE,
                                           includeLevelVsAll = TRUE,
                                           minCount = 1)


traits <- cbind(traits, severity.out)

# Define numbers of genes and samples
nSamples <- nrow(norm.counts)
nGenes <- ncol(norm.counts)


module.trait.corr <- cor(module_eigengenes, traits, use = 'p')
module.trait.corr.pvals <- corPvalueStudent(module.trait.corr, nSamples)

# visualize module-trait association as a heatmap

heatmap.data <- merge(module_eigengenes, traits, by = 'row.names')

head(heatmap.data)

heatmap.data <- heatmap.data %>% 
  column_to_rownames(var = 'Row.names')

#devtools::install_github("kevinblighe/CorLevelPlot")
library(CorLevelPlot)

CorLevelPlot(heatmap.data,
             x = names(heatmap.data)[29],   #Trait column
             y = names(heatmap.data)[1:28],
             col = c("blue1", "skyblue", "white", "pink", "red"))


pheatmap(heatmap.data,
             x = names(heatmap.data),   #Trait column
             y = names(heatmap.data),
             col = c("blue1", "skyblue", "white", "pink", "red"))




module.gene.mapping <- as.data.frame(bwnet$colors)
module.gene.mapping %>% 
  filter(`bwnet$colors` == 'lightgreen') %>% 
  rownames()


# 6B. Intramodular analysis: Identifying driver genes ---------------



# Calculate the module membership and the associated p-values

# The module membership/intramodular connectivity is calculated as the correlation of the eigengene and the gene expression profile. 
# This quantifies the similarity of all genes on the array to every module.



# Compute correlation
module.membership.measure <- cor(module_eigengenes, norm.counts, use = 'p')

# Compute p-values
module.membership.measure.pvals <- corPvalueStudent(module.membership.measure, nSamples)


module.membership.measure.pvals[1:10,1:10]


# Calculate the gene significance and associated p-values


# Compute correlation
gene.signf.corr <- cor(norm.counts, traits$treatment_bin, use = 'p')   #use the column name from traits data frame e.g treatment_bin

# Compute p-values
gene.signf.corr.pvals <- corPvalueStudent(gene.signf.corr, nSamples)


library(writexl)

# Convert to a data frame and save
gene.signf.corr.pvals_df <- gene.signf.corr.pvals %>% 
  as.data.frame() %>% 
  arrange(V1)

# Save to an Excel file
write_xlsx(gene.signf.corr.pvals_df, "gene_significance_pvalues.xlsx")


# Using the gene significance, you can identify genes that have a high significance for the trait of interest 
# Using the module membership measures, you can identify genes with high module membership in interesting modules.



